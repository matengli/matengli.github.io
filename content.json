{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/17/hello-world/"},{"title":"newArt","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587--[[Copyright (c) 2011-2014 chukong-inc.comPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the \"Software\"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.]]local display = {}local director = cc.Director:getInstance()local view = director:getOpenGLView()if not view then local width = 960 local height = 640 if CC_DESIGN_RESOLUTION then if CC_DESIGN_RESOLUTION.width then width = CC_DESIGN_RESOLUTION.width end if CC_DESIGN_RESOLUTION.height then height = CC_DESIGN_RESOLUTION.height end end view = cc.GLViewImpl:createWithRect(\"EleStorm\", cc.rect(0, 0, width, height)) director:setOpenGLView(view)endlocal framesize = view:getFrameSize()local textureCache = director:getTextureCache()local spriteFrameCache = cc.SpriteFrameCache:getInstance()local animationCache = cc.AnimationCache:getInstance()-- auto scalelocal function checkResolution(r) r.width = checknumber(r.width) r.height = checknumber(r.height) r.autoscale = string.upper(r.autoscale) assert(r.width &gt; 0 and r.height &gt; 0, string.format(\"display - invalid design resolution size %d, %d\", r.width, r.height))endlocal function setDesignResolution(r, framesize) if r.autoscale == \"FILL_ALL\" then view:setDesignResolutionSize(framesize.width, framesize.height, cc.ResolutionPolicy.FILL_ALL) else local scaleX, scaleY = framesize.width / r.width, framesize.height / r.height local width, height = framesize.width, framesize.height if r.autoscale == \"FIXED_WIDTH\" then width = framesize.width / scaleX height = framesize.height / scaleX view:setDesignResolutionSize(width, height, cc.ResolutionPolicy.NO_BORDER) elseif r.autoscale == \"FIXED_HEIGHT\" then width = framesize.width / scaleY height = framesize.height / scaleY view:setDesignResolutionSize(width, height, cc.ResolutionPolicy.NO_BORDER) elseif r.autoscale == \"EXACT_FIT\" then view:setDesignResolutionSize(r.width, r.height, cc.ResolutionPolicy.EXACT_FIT) elseif r.autoscale == \"NO_BORDER\" then view:setDesignResolutionSize(r.width, r.height, cc.ResolutionPolicy.NO_BORDER) elseif r.autoscale == \"SHOW_ALL\" then view:setDesignResolutionSize(r.width, r.height, cc.ResolutionPolicy.SHOW_ALL) else printError(string.format(\"display - invalid r.autoscale \\\"%s\\\"\", r.autoscale)) end endendlocal function setConstants() local sizeInPixels = view:getFrameSize() display.sizeInPixels = {width = sizeInPixels.width, height = sizeInPixels.height} local viewsize = director:getWinSize() display.contentScaleFactor = director:getContentScaleFactor() local maxOffsetX = 60 local maxOffsetY = 30 local safesize = director:getSafeAreaRect() safesize.x = math.round(safesize.x) safesize.y = math.round(safesize.y) safesize.width = math.round(safesize.width) safesize.height = math.round(safesize.height) safesize.x = safesize.x &gt; maxOffsetX and maxOffsetX or safesize.x safesize.y = safesize.y &gt; maxOffsetY and maxOffsetY or safesize.y local width = viewsize.width - maxOffsetX*2; safesize.width = safesize.width &gt;= width and safesize.width or width; local height = viewsize.height - maxOffsetY; safesize.height = safesize.height &gt;= height and safesize.height or height; local space = math.max(safesize.x, viewsize.width-safesize.width-safesize.x) safesize.x = space safesize.width = viewsize.width - space * 2 display.width = viewsize.width display.height = viewsize.height display.size = {width = safesize.width, height = safesize.height} display.sw = display.size.width display.sh = display.size.height display.cx = display.width / 2; display.cy = display.height / 2; display.left = safesize.x display.right = safesize.x + display.width display.top = safesize.y + display.height display.bottom = safesize.y display.cl = display.left - display.cx display.cr = display.right - display.cx display.ct = display.top - display.cy display.cb = display.bottom - display.cy display.center = cc.p(display.cx, display.cy) display.lt = cc.p(display.left, display.top) display.lb = cc.p(display.left, display.bottom) display.lc = cc.p(display.left, display.cy) display.rt = cc.p(display.right, display.top) display.rb = cc.p(display.right, display.bottom) display.rc = cc.p(display.right, display.cy) display.tc = cc.p(display.cx, display.top) display.tb = cc.p(display.cx, display.bottom) printInfo(string.format(\"# display.sizeInPixels = {width = %0.2f, height = %0.2f}\", display.sizeInPixels.width, display.sizeInPixels.height)) printInfo(string.format(\"# display.size = {width = %0.2f, height = %0.2f}\", display.sw, display.sh)) printInfo(string.format(\"# display.safesize = {width = %0.2f, height = %0.2f}\", display.size.width, display.size.height)) printInfo(string.format(\"# display.contentScaleFactor = %0.2f\", display.contentScaleFactor)) printInfo(string.format(\"# display.safewidth = %0.2f\", display.width)) printInfo(string.format(\"# display.safeheight = %0.2f\", display.height)) printInfo(string.format(\"# display.cx = %0.2f\", display.cx)) printInfo(string.format(\"# display.cy = %0.2f\", display.cy)) printInfo(string.format(\"# display.left = %0.2f\", display.left)) printInfo(string.format(\"# display.right = %0.2f\", display.right)) printInfo(string.format(\"# display.top = %0.2f\", display.top)) printInfo(string.format(\"# display.bottom = %0.2f\", display.bottom)) printInfo(string.format(\"# display.c_left = %0.2f\", display.cl)) printInfo(string.format(\"# display.c_right = %0.2f\", display.cr)) printInfo(string.format(\"# display.c_top = %0.2f\", display.ct)) printInfo(string.format(\"# display.c_bottom = %0.2f\", display.cb)) printInfo(string.format(\"# display.center = {x = %0.2f, y = %0.2f}\", display.center.x, display.center.y)) printInfo(string.format(\"# display.left_top = {x = %0.2f, y = %0.2f}\", display.lt.x, display.lt.y)) printInfo(string.format(\"# display.left_bottom = {x = %0.2f, y = %0.2f}\", display.lb.x, display.lb.y)) printInfo(string.format(\"# display.left_center = {x = %0.2f, y = %0.2f}\", display.lc.x, display.lc.y)) printInfo(string.format(\"# display.right_top = {x = %0.2f, y = %0.2f}\", display.rt.x, display.rt.y)) printInfo(string.format(\"# display.right_bottom = {x = %0.2f, y = %0.2f}\", display.rb.x, display.rb.y)) printInfo(string.format(\"# display.right_center = {x = %0.2f, y = %0.2f}\", display.rc.x, display.rc.y)) printInfo(string.format(\"# display.top_center = {x = %0.2f, y = %0.2f}\", display.tc.x, display.tc.y)) printInfo(string.format(\"# display.top_bottom = {x = %0.2f, y = %0.2f}\", display.tb.x, display.tb.y)) printInfo(\"#\")endfunction display.setAutoScale(configs) if type(configs) ~= \"table\" then return end checkResolution(configs) if type(configs.callback) == \"function\" then local c = configs.callback(framesize) for k, v in pairs(c or {}) do configs[k] = v end checkResolution(configs) end setDesignResolution(configs, framesize) printInfo(string.format(\"# design resolution size = {width = %0.2f, height = %0.2f}\", configs.width, configs.height)) printInfo(string.format(\"# design resolution autoscale = %s\", configs.autoscale)) setConstants()endif type(CC_DESIGN_RESOLUTION) == \"table\" then display.setAutoScale(CC_DESIGN_RESOLUTION)enddisplay.COLOR_WHITE = cc.c3b(255, 255, 255)display.COLOR_BLACK = cc.c3b(0, 0, 0)display.COLOR_RED = cc.c3b(255, 0, 0)display.COLOR_GREEN = cc.c3b(0, 255, 0)display.COLOR_BLUE = cc.c3b(0, 0, 255)display.AUTO_SIZE = 0display.FIXED_SIZE = 1display.LEFT_TO_RIGHT = 0display.RIGHT_TO_LEFT = 1display.TOP_TO_BOTTOM = 2display.BOTTOM_TO_TOP = 3display.CENTER = cc.p(0.5, 0.5)display.LEFT_TOP = cc.p(0, 1)display.LEFT_BOTTOM = cc.p(0, 0)display.LEFT_CENTER = cc.p(0, 0.5)display.RIGHT_TOP = cc.p(1, 1)display.RIGHT_BOTTOM = cc.p(1, 0)display.RIGHT_CENTER = cc.p(1, 0.5)display.CENTER_TOP = cc.p(0.5, 1)display.CENTER_BOTTOM = cc.p(0.5, 0)display.SCENE_TRANSITIONS = { CROSSFADE = {cc.TransitionCrossFade}, FADE = {cc.TransitionFade, cc.c3b(0, 0, 0)}, FADEBL = {cc.TransitionFadeBL}, FADEDOWN = {cc.TransitionFadeDown}, FADETR = {cc.TransitionFadeTR}, FADEUP = {cc.TransitionFadeUp}, FLIPANGULAR = {cc.TransitionFlipAngular, cc.TRANSITION_ORIENTATION_LEFT_OVER}, FLIPX = {cc.TransitionFlipX, cc.TRANSITION_ORIENTATION_LEFT_OVER}, FLIPY = {cc.TransitionFlipY, cc.TRANSITION_ORIENTATION_UP_OVER}, JUMPZOOM = {cc.TransitionJumpZoom}, MOVEINB = {cc.TransitionMoveInB}, MOVEINL = {cc.TransitionMoveInL}, MOVEINR = {cc.TransitionMoveInR}, MOVEINT = {cc.TransitionMoveInT}, PAGETURN = {cc.TransitionPageTurn, false}, ROTOZOOM = {cc.TransitionRotoZoom}, SHRINKGROW = {cc.TransitionShrinkGrow}, SLIDEINB = {cc.TransitionSlideInB}, SLIDEINL = {cc.TransitionSlideInL}, SLIDEINR = {cc.TransitionSlideInR}, SLIDEINT = {cc.TransitionSlideInT}, SPLITCOLS = {cc.TransitionSplitCols}, SPLITROWS = {cc.TransitionSplitRows}, TURNOFFTILES = {cc.TransitionTurnOffTiles}, ZOOMFLIPANGULAR = {cc.TransitionZoomFlipAngular}, ZOOMFLIPX = {cc.TransitionZoomFlipX, cc.TRANSITION_ORIENTATION_LEFT_OVER}, ZOOMFLIPY = {cc.TransitionZoomFlipY, cc.TRANSITION_ORIENTATION_UP_OVER},}-- display.TEXTURES_PIXEL_FORMAT = {}display.DEFAULT_TTF_FONT = \"Arial\"display.DEFAULT_TTF_FONT_SIZE = 32local PARAMS_EMPTY = {}local RECT_ZERO = cc.rect(0, 0, 0, 0)local sceneIndex = 0function display.newScene(name, params) params = params or PARAMS_EMPTY sceneIndex = sceneIndex + 1 local scene if not params.physics then scene = cc.Scene:create() else scene = cc.Scene:createWithPhysics() end scene.name_ = string.format(\"%s:%d\", name or \"&lt;unknown-scene&gt;\", sceneIndex) if params.transition then scene = display.wrapSceneWithTransition(scene, params.transition, params.time, params.more) end return sceneendfunction display.wrapScene(scene, transition, time, more) local key = string.upper(tostring(transition)) if key == \"RANDOM\" then local keys = table.keys(display.SCENE_TRANSITIONS) key = keys[math.random(1, #keys)] end if display.SCENE_TRANSITIONS[key] then local t = display.SCENE_TRANSITIONS[key] local cls = t[1] time = time or 0.2 more = more or t[2] if more ~= nil then scene = cls:create(time, scene, more) else scene = cls:create(time, scene) end else error(string.format(\"display.wrapScene() - invalid transition %s\", tostring(transition))) end return sceneendfunction display.runScene(newScene, transition, time, more) if director:getRunningScene() then if transition then newScene = display.wrapScene(newScene, transition, time, more) end director:replaceScene(newScene) else director:runWithScene(newScene) endendfunction display.getRunningScene() return director:getRunningScene()endfunction display.newNode() return cc.Node:create()endfunction display.newLayer(...) local params = {...} local c = #params local layer if c == 0 then -- /** creates a fullscreen black layer */ -- static Layer *create(); layer = cc.Layer:create() elseif c == 1 then -- /** creates a Layer with color. Width and height are the window size. */ -- static LayerColor * create(const Color4B&amp; color); layer = cc.LayerColor:create(cc.convertColor(params[1], \"4b\")) elseif c == 2 then -- /** creates a Layer with color, width and height in Points */ -- static LayerColor * create(const Color4B&amp; color, const Size&amp; size); -- -- /** Creates a full-screen Layer with a gradient between start and end. */ -- static LayerGradient* create(const Color4B&amp; start, const Color4B&amp; end); local color1 = cc.convertColor(params[1], \"4b\") local p2 = params[2] assert(type(p2) == \"table\" and (p2.width or p2.r), \"display.newLayer() - invalid paramerter 2\") if p2.r then layer = cc.LayerGradient:create(color1, cc.convertColor(p2, \"4b\")) else layer = cc.LayerColor:create(color1, p2.width, p2.height) end elseif c == 3 then -- /** creates a Layer with color, width and height in Points */ -- static LayerColor * create(const Color4B&amp; color, GLfloat width, GLfloat height); -- -- /** Creates a full-screen Layer with a gradient between start and end in the direction of v. */ -- static LayerGradient* create(const Color4B&amp; start, const Color4B&amp; end, const Vec2&amp; v); local color1 = cc.convertColor(params[1], \"4b\") local p2 = params[2] local p2type = type(p2) if p2type == \"table\" then layer = cc.LayerGradient:create(color1, cc.convertColor(p2, \"4b\"), params[3]) else layer = cc.LayerColor:create(color1, p2, params[3]) end end return layerendfunction display.newSprite(source, x, y, params) local spriteClass = cc.Sprite local scale9 = false if type(x) == \"table\" and not x.x then -- x is params params = x x = nil y = nil end local params = params or PARAMS_EMPTY if params.scale9 or params.capInsets then spriteClass = ccui.Scale9Sprite scale9 = true params.capInsets = params.capInsets or RECT_ZERO params.rect = params.rect or RECT_ZERO end local sprite while true do -- create sprite if not source then sprite = spriteClass:create() break end local sourceType = type(source) if sourceType == \"string\" then if string.byte(source) == 35 then -- first char is # -- create sprite from spriteFrame if not scale9 then sprite = spriteClass:createWithSpriteFrameName(string.sub(source, 2)) else sprite = spriteClass:createWithSpriteFrameName(string.sub(source, 2), params.capInsets) end break end -- create sprite from image file -- if display.TEXTURES_PIXEL_FORMAT[source] then -- cc.Texture2D:setDefaultAlphaPixelFormat(display.TEXTURES_PIXEL_FORMAT[source]) -- end if not scale9 then sprite = spriteClass:create(source) else sprite = spriteClass:create(source, params.rect, params.capInsets) end -- if display.TEXTURES_PIXEL_FORMAT[source] then -- cc.Texture2D:setDefaultAlphaPixelFormat(cc.TEXTURE2_D_PIXEL_FORMAT_BGR_A8888) -- end break elseif sourceType ~= \"userdata\" then error(string.format(\"display.newSprite() - invalid source type \\\"%s\\\"\", sourceType), 0) else sourceType = tolua.type(source) if sourceType == \"cc.SpriteFrame\" then if not scale9 then sprite = spriteClass:createWithSpriteFrame(source) else sprite = spriteClass:createWithSpriteFrame(source, params.capInsets) end elseif sourceType == \"cc.Texture2D\" then sprite = spriteClass:createWithTexture(source) else error(string.format(\"display.newSprite() - invalid source type \\\"%s\\\"\", sourceType), 0) end end break end if sprite then if x and y then sprite:setPosition(x, y) end if params.size then sprite:setContentSize(params.size) end else error(string.format(\"display.newSprite() - create sprite failure, source \\\"%s\\\"\", tostring(source)), 0) end return spriteendfunction display.newSpriteFrame(source, ...) local frame if type(source) == \"string\" then if string.byte(source) == 35 then -- first char is # source = string.sub(source, 2) end frame = spriteFrameCache:getSpriteFrame(source) if not frame then error(string.format(\"display.newSpriteFrame() - invalid frame name \\\"%s\\\"\", tostring(source)), 0) end elseif tolua.type(source) == \"cc.Texture2D\" then frame = cc.SpriteFrame:createWithTexture(source, ...) else error(\"display.newSpriteFrame() - invalid parameters\", 0) end return frameendfunction display.newFrames(pattern, begin, length, isReversed) local frames = {} local step = 1 local last = begin + length - 1 if isReversed then last, begin = begin, last step = -1 end for index = begin, last, step do local frameName = string.format(pattern, index) local frame = spriteFrameCache:getSpriteFrame(frameName) if not frame then error(string.format(\"display.newFrames() - invalid frame name %s\", tostring(frameName)), 0) end frames[#frames + 1] = frame end return framesendlocal function newAnimation(frames, time) local count = #frames assert(count &gt; 0, \"display.newAnimation() - invalid frames\") time = time or 1.0 / count return cc.Animation:createWithSpriteFrames(frames, time), cc.Sprite:createWithSpriteFrame(frames[1])endfunction display.newAnimation(...) local params = {...} local c = #params if c == 2 then -- frames, time return newAnimation(params[1], params[2]) elseif c == 4 then -- pattern, begin, length, time local frames = display.newFrames(params[1], params[2], params[3]) return newAnimation(frames, params[4]) elseif c == 5 then -- pattern, begin, length, isReversed, time local frames = display.newFrames(params[1], params[2], params[3], params[4]) return newAnimation(frames, params[5]) else error(\"display.newAnimation() - invalid parameters\") endendfunction display.loadImage(imageFilename, callback) if not callback then return textureCache:addImage(imageFilename) else textureCache:addImageAsync(imageFilename, callback) end if CACHE_RES then CACHE_RES[\"imageType\"][imageFilename] = 1 endendlocal fileUtils = cc.FileUtils:getInstance()function display.getImage(imageFilename) local fullpath = fileUtils:fullPathForFilename(imageFilename) return textureCache:getTextureForKey(fullpath) endfunction display.removeImage(imageFilename) textureCache:removeTextureForKey(imageFilename) if CACHE_RES then CACHE_RES[\"imageType\"][imageFilename] = nil endendfunction display.loadSpriteFrames(dataFilename, imageFilename, callback) -- if display.TEXTURES_PIXEL_FORMAT[imageFilename] then -- cc.Texture2D:setDefaultAlphaPixelFormat(display.TEXTURES_PIXEL_FORMAT[imageFilename]) -- end if not callback then spriteFrameCache:addSpriteFrames(dataFilename, imageFilename) else spriteFrameCache:addSpriteFramesAsync(dataFilename, imageFilename, callback) end -- if display.TEXTURES_PIXEL_FORMAT[imageFilename] then -- cc.Texture2D:setDefaultAlphaPixelFormat(cc.TEXTURE2_D_PIXEL_FORMAT_BGR_A8888) -- end if CACHE_RES then CACHE_RES[\"plistType\"][dataFilename] = imageFilename endendfunction display.removeSpriteFrames(dataFilename, imageFilename) spriteFrameCache:removeSpriteFramesFromFile(dataFilename) if imageFilename then display.removeImage(imageFilename) end if CACHE_RES then CACHE_RES[\"plistType\"][dataFilename] = nil endendfunction display.removeSpriteFrame(imageFilename) spriteFrameCache:removeSpriteFrameByName(imageFilename)end-- function display.setTexturePixelFormat(imageFilename, format)-- display.TEXTURES_PIXEL_FORMAT[imageFilename] = format-- endfunction display.setAnimationCache(name, animation) animationCache:addAnimation(animation, name)endfunction display.getAnimationCache(name) return animationCache:getAnimation(name)endfunction display.removeAnimationCache(name) animationCache:removeAnimation(name)endfunction display.removeUnusedSpriteFrames() -- spriteFrameCache:removeUnusedSpriteFrames() -- textureCache:removeUnusedTextures() if CACHE_RES then CACHE_RES[\"plistType\"] = {} CACHE_RES[\"imageType\"] = {} endendreturn display","link":"/2021/09/17/newArt/"}],"tags":[],"categories":[]}